Asset Pipeline
==============

Это руководство раскрывает файлопровод (asset pipeline).

Обратившись к этому руководству, вы узнаете:

* Что такое файлопровод, и зачем он нужен.
* Как должным образом организовывать ассеты своего приложения.
* Преимущества файлопровода.
* Как добавить препроцессор к файлопроводу.
* Как упаковывать ассеты в гем.

(what-is-the-asset-pipeline) Что такое файлопровод (Asset Pipeline)?
--------------------------------------------------------------------

Файлопровод представляет фреймворк для соединения и минимизации или сжатия ассетов JavaScript и CSS. Он также добавляет возможность писать эти ассеты на других языках и препроцессорах, таких как CoffeeScript, Sass и ERB. Это позволяет автоматически комбинировать ассеты приложения с ассетами других гемов.

Файлопровод реализован в геме [sprockets-rails](https://github.com/rails/sprockets-rails) и включен по умолчанию. Можно отключить файлопровод при создании нового приложения, передав опцию `--skip-asset-pipeline`.

```bash
$ rails new appname --skip-asset-pipeline
```

В Rails может с легкостью работать с Sass, добавив гем [`sassc-rails`](https://github.com/rails/sass-rails) в ваш `Gemfile`, который используются Sprockets для компиляции [Sass](https://sass-lang.com):

```ruby
gem 'sassc-rails'
```

Чтобы установить методы компрессии ассетов, установите соответствующие конфигурационные опции в `production.rb` - [`config.assets.css_compressor`][] для CSS и [`config.assets.js_compressor`][] для JavaScript:

```ruby
config.assets.css_compressor = :yui
config.assets.js_compressor = :terser
```

NOTE: Гем `sassc-rails` автоматически используется для сжатия CSS, если он подключен в `Gemfile`, опцию `config.assets.css_compressor` устанавливать не нужно.

[`config.assets.css_compressor`]: /configuring#config-assets-css-compressor
[`config.assets.js_compressor`]: /configuring#config-assets-js-compressor

### Основные особенности

Первой особенностью файлопровода является соединение ассетов, что может уменьшить количество запросов, необходимых браузеру для отображения страницы. Браузеры ограничены в количестве запросов, которые они могут выполнить параллельно, поэтому меньшее количество запросов может означать более быструю загрузку вашего приложения.

Sprockets соединяет все JavaScript файлы в один главный файл `.js` и все CSS файлы в один главный файл `.css`. Как будет сказано далее в этом руководстве, можно настроить эту стратегию, сгруппировав файлы любым способом. В production, Rails вставляет метку SHA256 в каждое имя файла, таким образом файл кэшируется браузером. Кэш можно сделать недействительным, изменив эту метку, что происходит автоматически каждый раз, когда изменяется содержимое файла.

Второй особенностью файлопровода является минимизация или сжатие ассетов. Для файлов CSS это выполняется путем удаления пробелов и комментариев. Для JavaScript могут быть применены более сложные процессы. Можно выбирать из набора встроенных опций или определить свои.

Третьей особенностью файлопровода является то, что он позволяет писать эти ассеты на языке более высокого уровня с дальнейшей прекомпиляцией до фактического ассета. Поддерживаемые языки по умолчанию включают Sass для CSS, CoffeeScript для JavaScript и ERB для обоих.

### Что за метки и зачем они нужны?

Метки (fingerprinting) - это техника, реализующая зависимость имени файла от его содержимого. При изменении содержимого файла, имя файла также изменяется. Для статичного или нечасто обновляемого содержимого это предоставляет легкий способ сказать, идентичны ли две версии файла, даже если они на разных серверах, или имеют различную дату размещения.

Когда имя файла уникально и основано на его содержимом, заголовками HTTP можно установить повсеместное кэширование (в CDN, у провайдера, в сетевом оборудовании или браузере), чтобы у них была собственная копия содержимого. Когда содержимое изменяется, метка тоже изменится. Это приведет к тому, что удаленные клиенты запросят новую копию содержимого. Эта техника известна как _cache busting_.

Техникой, используемой Sprockets для меток, является вставка хэша содержимого в имя, обычно в конце. Например, файл CSS `global.css`:

```
global-908e25f4bf641868d8683022a5b62f54.css
```

Это стратегия, принятая файлопроводом Rails.

Прежней стратегией Rails было добавление строки запроса, основанной на дате, к каждому ассету, присоединенному с помощью встроенного хелпера. В исходнике сгенерированный код выглядел так:

```
/stylesheets/global.css?1309495796
```

У стратегии, основанной на строке запроса, имелось несколько недостатков:

1. **Не все кэши надежно кэшировали содержимое, когда имя файла отличалось только параметрами строки запроса**

    [Steve Souders рекомендует](https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/), "...избегать строки запросов для кэшируемых ресурсов". Он обнаружил, что в этом случае 5-20% запросов не будут закэшированы. В частности, строки запроса совсем не работают с некоторыми сетями доставки контента (CDN) для инвалидации кэша.

2. **Имя файла может быть разным на разных узлах в мультисерверных окружениях.**

    По умолчанию, строка запроса в Rails 2.x основывается на времени модификации файлов. Когда ассеты размещаются в кластер, нет никакой гарантии, что временная метка будет одной и той же, в результате будут использованы различные значения в зависимости от того, какой сервер будет обрабатывать запрос.

3. **Слишком много прекращенного кэша**

    При размещении статичных ассетов с каждым новым релизом кода, mtime (время последней модификации) _всех_ этих файлов изменялось, принуждая всех удаленных клиентов получать их снова, даже если содержимое этих ассетов не менялось.

Метки исправляют эти проблемы, избегая строки запроса и обеспечивая то, что имя файла основывается на его содержимом.

По умолчанию метки включены для сред development и production. Их можно включить или отключить в конфигурации с помощью опции [`config.assets.digest`][].

Более подробно:

* [Optimize caching](https://developers.google.com/speed/docs/insights/LeverageBrowserCaching)
* [Revving Filenames: don't use querystring](http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/)

[`config.assets.digest`]: /configuring#config-assets-digest

(how-to-use-the-asset-pipeline) Как использовать файлопровод (Asset Pipeline)
-----------------------------------------------------------------------------

В прежних версиях Rails, все ассеты были расположены в поддиректориях `public`, таких как `images`, `javascripts` и `stylesheets`. Сейчас, с файлопроводом, предпочтительным местом расположения для этих ассетов стала директория `app/assets`. Файлы в этой директории отдаются промежуточной программой Sprockets.

Ассеты все еще могут быть размещены в `public`. Любой ассет в `public` будет отдан как статичный файл приложением или веб-сервером, когда [`config.public_file_server.enabled`][] установлена true. Следует использовать `app/assets` для файлов, которые должны пройти некоторую предварительную обработку перед тем, как будут отданы.

По умолчанию в production Rails прекомпилирует эти файлы в `public/assets`. Прекомпилированные копии затем отдаются веб-сервером как статичные ассеты. Файлы в `app/assets` никогда не отдаются напрямую в production.

[`config.public_file_server.enabled`]: /configuring#config-public-file-server-enabled

### Ассеты конкретного контроллера

При генерации скаффолда или контроллера, Rails также генерирует файл CSS (или файл SCSS, если `sass-rails` имеется в `Gemfile`) для этого контроллера. Дополнительно при генерации скаффолда, Rails генерирует файл `scaffolds.css` (или `scaffolds.scss`, если `sass-rails` находится в `Gemfile`.)

Например, если генерируете `ProjectsController`, Rails также добавит новый файл `app/assets/stylesheets/projects.scss`. По умолчанию эти файлы будут готовы к немедленному использованию вашим приложением, с помощью директивы `require_tree`. Смотрите [Файлы манифеста и директивы](#manifest-files-and-directives) о подробностях `require_tree`.

Опционально можно включить таблицы стилей и файлы JavaScript конкретного контроллера только для их соответствующих контроллеров, используя следующее:

`<%= javascript_include_tag params[:controller] %>` или `<%= stylesheet_link_tag params[:controller] %>`.

При этом убедитесь, что не используете директиву `require_tree`, так как она приведет к тому, что ассеты будут включены более одного раза.

WARNING: При использовании прекомпиляции ассетов, необходимо убедиться, что ассеты контроллера будут прекомпилированы при варианте загрузки их на основе страницы. По умолчанию файлы `.coffee` и `.scss` не будут прекомпилированы отдельно. Смотрите [Прекомпиляция ассетов](#in-production) о подробностях работы прекомпиляции.

NOTE: Вам необходим runtime, поддерживаемый ExecJS, чтобы использовать CoffeeScript. Если используете macOS или Windows, у вас уже имеется JavaScript runtime, установленный в операционной системе. Обратитесь к документации по [ExecJS](https://github.com/rails/execjs#readme), чтобы узнать обо всех поддерживаемых JavaScript runtime-ах.

### Организация ассетов

Ассеты файлопровода могут быть размещены в приложении в одном из этих трех мест расположений: `app/assets`, `lib/assets` или `vendor/assets`.

* `app/assets` предназначено для ассетов, принадлежащих приложению, таких как изображения, файлы JavaScript или таблицы стилей, изготовленные специально для приложения.

* `lib/assets` предназначено для кода собственных библиотек, которые не вписываются в область видимости приложения или эти библиотеки являются общими для нескольких приложений.

* `vendor/assets` предназначено для ассетов, принадлежащих сторонним субъектам, таких как код плагинов JavaScript и фреймворки CSS. Имейте в виду, что код третьей стороны со ссылками на другие файлы, также обрабатывающиеся файлопроводом (изображения, таблицы стилей и так далее), должен быть переписан с помощью хелперов, таких как `asset_path`.

#### Пути поиска

Когда к файлу обращаются из манифеста или хелпера, Sprockets ищет в трех дефолтных местах расположения ассетов для этого файла.

Дефолтные места расположения следующие: директории `images`, `javascripts` и `stylesheets` в папке `app/assets`, но эти поддиректории не особенные - поиск будет вестись по любому пути в `assets/*`.

Для примера, на эти файлы:

```
app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js
```

можно сослаться в манифесте таким образом:

```js
//= require home
//= require moovinator
//= require slider
//= require phonebox
```

Ассеты в поддиректориях также доступны.

```
app/assets/javascripts/sub/something.js
```

доступен как:

```js
//= require sub/something
```

Можно просмотреть путь поиска, проинспектировав [`Rails.application.config.assets.paths`][`config.assets.paths`] в консоли Rails.

Помимо стандартных путей `assets/*` в файлопровод могут быть добавлены дополнительные (полностью ограниченные) пути в `config/initializers/assets.rb`. Например:

```ruby
Rails.application.config.assets.paths << Rails.root.join("lib", "videoplayer", "flash")
```

Пути обходятся в том порядке, в котором они выводятся в пути поиска. По умолчанию это означает, что имеют преимущество файлы в `app/assets`, они перекроют соответствующие пути в `lib` и `vendor`.

Важно заметить, что если хотите сослаться на что-то еще, в прекомпилированный массив должен быть добавлен манифест, или оно не будет доступно в среде production.

[`config.assets.paths`]: /configuring#config-assets-paths

#### Использование индексных файлов

Sprockets использует файлы с именем `index` (с соответствующим расширением) для специальных целей.

Например, если имеется библиотека jQuery с множеством модулей, хранящаяся в `lib/assets/javascripts/library_name`, файл `lib/assets/javascripts/library_name/index.js` служит манифестом для всех файлов в этой библиотеке. Этот файл может включать список всех требуемых файлов в нужном порядке, или просто директиву `require_tree`.

Библиотека в целом может быть доступна из манифеста приложения следующим образом:

```js
//= require library_name
```

Это упрощает поддержку и сохраняет чистоту, позволяя коду быть сгруппированным перед включением где-нибудь еще.

### Кодирование ссылок на ассеты

Sprockets не добавляет какие-либо новые методы для доступа к вашим ассетам - используйте знакомые методы `javascript_include_tag` и `stylesheet_link_tag`.

```erb
<%= stylesheet_link_tag "application", media: "all" %>
<%= javascript_include_tag "application" %>
```

При использовании гема turbolinks, который включен по умолчанию в Rails, включите опцию 'data-turbo-track', которая вызывает проверку Turbo, что ассет был обновлен, таким образом загружая его на страницу:

```erb
<%= stylesheet_link_tag "application", media: "all", "data-turbo-track" => "reload" %>
<%= javascript_include_tag "application", "data-turbo-track" => "reload" %>
```

В обычных вью можно получить доступ к изображениям в директории `app/assets/images` следующим образом:

```erb
<%= image_tag "rails.png" %>
```

При условии, что файлопровод включен в вашем приложении (и не отключен в контексте текущей среды), этот файл будет отдан с помощью Sprockets. Если файл существует в `public/assets/rails.png`, он будет отдан веб-сервером.

Кроме того, запрос файла с хэшем SHA256, такого как `public/assets/rails-f90d8a84c707a8dc923fca1ca1895ae8ed0a09237f6992015fef1e11be77c023.png` будет обработан тем же образом. Как генерируются эти хэши будет раскрыто позже в этом руководстве в разделе [В production](#in-production).

Sprockets также будет смотреть среди путей, определенных в [`config.assets.paths`][], включающих стандартные пути приложения и любые пути, добавленные engine-ами Rails.

Изображения также могут быть организованы в поддиректории и могут быть доступны с помощью указания имени директории в теге:

```erb
<%= image_tag "icons/rails.png" %>
```

WARNING: Если вы прекомпилируете ассеты (смотрите раздел [В production](#in-production) далее), связывание с несуществующим ассетом вызовет исключение на вызывающей странице. Это также справедливо и для связывания с пустой строкой. Поэтому будьте осторожны при использовании `image_tag` и других хелперов с данными, предоставленными пользователями.

#### CSS и ERB

Файлопровод автоматически вычисляет ERB. Это означает, что, если добавить расширение `erb` к ассету CSS (например, `application.css.erb`), будут доступны хелперы, такие как `asset_path`, в правилах вашего CSS:

```css
.class { background-image: url(<%= asset_path 'image.png' %>) }
```

Этот фрагмент кода записывает путь к определенному указанному ассету. Этот пример имеет смысл, если имеется изображение в одном из путей загрузки ассетов, такое как `app/assets/images/image.png`, на которое тут будет ссылка. Если это изображение уже имеется в `public/assets` как файл с меткой, то будет ссылка на него.

Если хотите использовать [data URI](https://ru.wikipedia.org/wiki/Data:_URL) - метод встраивания данных изображения непосредственно в файл CSS - используйте хелпер `asset_data_uri`.

```css
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }
```

Этот фрагмент кода вставит правильно отформатированный URI в код CSS.

Отметьте, что закрывающий тег не может быть в стиле `-%>`.

#### CSS и Sass

При использовании файлопровода пути к ассетам должны быть переписаны. `sass-rails` предоставляет хелперы `-url` и `-path` (через дефис в Sass, через подчеркивание в Ruby) для следующих классов ассета: изображение, шрифт, видео, аудио, JavaScript и таблица стилей.

* `image-url("rails.png")` возвращает `url(/assets/rails.png)`
* `image-path("rails.png")` возвращает `"/assets/rails.png"`.

Также может быть использована более общая форма:

* `asset-url("rails.png")` возвращает `url(/assets/rails.png)`
* `asset-path("rails.png")` возвращает `"/assets/rails.png"`

#### JavaScript/CoffeeScript и ERB

Если добавить расширение `erb` к ассету JavaScript, сделав его чем-то вроде `application.js.erb`, можно использовать хелпер `asset_path` в коде вашего JavaScript:

```erb
document.getElementById('logo').src = "<%= asset_path('logo.png') %>"
```

Этот фрагмент кода записывает путь к определенному указанному ассету.

### (manifest-files-and-directives) Файлы манифеста и директивы

Sprockets использует файлы манифеста для определения, какие ассеты включать и отдавать. Эти файлы манифеста содержат _директивы_ - инструкции, говорящие Sprockets, какие файлы требуются для создания отдельного файла CSS или JavaScript. С помощью этих директив Sprockets загружает указанные файлы, при необходимости их обрабатывает, соединяет в отдельный файл и затем сжимает их (основываясь на значении `Rails.application.config.assets.js_compressor`). При отдаче одного файла, а не нескольких, время загрузки страницы значительно уменьшается, поскольку браузер делает меньше запросов. Компрессия также уменьшает размер файла, что позволяет браузеру быстрее его скачать.

К примеру, файл `app/assets/javascripts/application.js`, содержащий следующие строчки:

```js
// ...
//= require rails-ujs
//= require turbolinks
//= require_tree .
```

В файлах JavaScript директивы начинаются с `//=`. В вышеприведенном примере файл использует директивы `require` и `require_tree`. Директива `require` используется, чтобы указать Sprockets на требуемые файлы. Здесь затребованы файлы `rails-ujs.js` и `turbolinks.js`, которые доступны где-то по пути поиска для Sprockets. Не нужно явно указывать расширение. Sprockets предполагает, что вы требуете файл `.js`, когда выполняется из файла `.js`.

Директива `require_tree` говорит Sprockets рекурсивно включить _все_ файлы JavaScript в указанной директории в результирующий файл. Эти пути должны быть определены только относительно файла манифеста. Также можно использовать директиву `require_directory`, включающая все файлы JavaScript только в определенной директории, без рекурсии.

Директивы обрабатываются сверху вниз, но порядок, в котором файлы включаются с помощью `require_tree` не определен. Не следует полагаться на какой-то определенный порядок при ее использовании. Если хотите убедиться, что какой-то определенный JavaScript закончится до некоторого другого в объединенном файле, затребуйте нужный файл раньше в манифесте. Отметьте, что семейство директив `require` предотвращает повторное включения файлов в результирующий файл.

Rails также создает дефолтный файл `app/assets/stylesheets/application.css`, содержащий эти строчки:

```css
/* ...
 *= require_self
 *= require_tree .
 */
```

Rails создает `app/assets/stylesheets/application.css` независимо от того, была ли выбрана опция `--skip-asset-pipeline` при создании нового приложения Rails. Это для того, чтобы было легко добавить файлопровод в будущем, если захотите.

Директивы, работающие в файлах JavaScript, также работают в таблицах стилей (хотя, очевидно, включая таблицы стилей вместо JavaScript). В манифесте CSS директива `require_tree` работает так же, как и для JavaScript, включающая все таблицы стилей из текущей директории.

В этом примере использована `require_self`. Это помещает CSS, содержащийся в файле (если есть) в месте расположения вызова `require_self`.

NOTE. Если хотите использовать несколько файлов Sass, как правило следует использовать [правило Sass `@import`](https://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import) вместо директив Sprockets. При использовании директив Sprockets все файлы существуют в своей собственной области видимости, что делает переменные или примеси (mixins) доступными только в определяющем их документе.

Можно подключить несколько файлов с помощью `@import "*"`, и добавить все дерево с помощью `@import "**/*"`, что эквивалентно `require_tree`. Обратитесь к [документации sass-rails](https://github.com/rails/sass-rails#features) за подробностями и важными предостережениями.

Можно иметь сколько угодно манифестов. Для примера, манифесты `admin.css` и `admin.js` могут содержать файлы JS и CSS, используемые для административного раздела приложения.

Применяются те же оговорки о порядке следования, что сделаны выше. В частности, можно определить отдельные файлы и порядок, в котором они будут компилироваться. Например, можно соединить три файла CSS вместе следующим образом:

```css
/* ...
 *= require reset
 *= require layout
 *= require chrome
 */
```

### Предварительная обработка

Расширение, использованное для ассета, определяет, какая будет применена предварительная обработка. Когда генерируется скаффолд или контроллер с помощью дефолтного набора гемов Rails, сгенерируются файл SCSS вместо обычного файла CSS. В использованном ранее примере был контроллер с именем "projects", который сгенерировал файл `app/assets/stylesheets/projects.scss`.

В режиме development или если отключен файлопровод, когда запрашивается этот файл, он обрабатывается процессором, предоставленным гемом `sass`, а затем отдается браузеру как CSS. Когда файлопровод включен, этот файл обрабатывается и помещается в директорию `public/assets` для раздачи либо приложением Rails, или веб-сервером.

Может быть запрошен дополнительный уровень обработки, если добавить другое расширение, каждое расширение обрабатывается в порядке справа налево. Их следует использовать в том порядке, в котором должна быть применена обработка. Например, таблица стилей с именем `app/assets/stylesheets/projects.scss.erb` сначала обрабатывается как ERB, затем SCSS и, наконец, отдается как CSS. То же самое применимо к файлу JavaScript - `app/assets/javascripts/projects.coffee.erb` обрабатывается как ERB, затем CoffeeScript и отдается как JavaScript.

Помните, что порядок этих препроцессоров важен. Например, если вы вызовете свой файл JavaScript `app/assets/javascripts/projects.erb.coffee`, то он будет сначала обработан интерпретатором CoffeeScript, который не понимает ERB, и, следовательно, возникнут проблемы.

(in-development) В development
------------------------------

В режиме development ассеты отдаются как соединенный файл.

Этот манифест `app/assets/javascripts/application.js`:

```js
//= require core
//= require projects
//= require tickets
```

сгенерирует этот HTML:

```html
<script src="/assets/application-728742f3b9daa182fe7c831f6a3b8fa87609b4007fdc2f87c134a07b19ad93fb.js"></script>
```

### Вызов ошибки, если ассет не найден

Если используется sprockets-rails >= 3.2.0, можно настроить, что произойдет, когда выполнен поиск ассета, и ничего не было найдено. Если выключить "asset fallback", тогда будет вызвана ошибка, когда ассет не может быть найден.

```ruby
config.assets.unknown_asset_fallback = false
```

Если "asset fallback" включен, тогда, когда ассет не может быть найден, вместо этого будет выведен путь, а не вызвана ошибка. Поведение "asset fallback" выключено по умолчанию.

### Включение  дайджестов

Можно отключить дайджесты, добавив в `config/environments/development.rb`:

```ruby
config.assets.digest = false
```

Когда эта опция true, для URL ассета будет генерироваться дайджест.

### Включение карт исходников

Можно включить карты исходников, добавив в `config/environments/development.rb`:

```ruby
config.assets.debug = true
```

Когда включена отладка, Sprockets сгенерирует карту исходников для каждого ассета. Это позволит вам отлаживать каждый файл по отдельности в средствах разработчика вашего браузера.

Ассеты компилируются и кэшируются при первом запросе после запуска сервера. Sprockets устанавливает HTTP-заголовок контроля кэша `must-revalidate` для уменьшения нагрузки на последующие запросы - на них браузер получает отклик 304 (Not Modified).

Если какой-либо из файлов в манифесте меняется между запросами, сервер возвращает новый скомпилированный файл.

(in-production) В production
----------------------------

В среде production Sprockets использует схему меток, [описанную ранее](#what-is-the-asset-pipeline). По умолчанию Rails полагает, что ассеты прекомпилированы и будут отданы как статичные ассеты вашим веб-сервером.

В течение фазы прекомпиляции из содержимого компилированных файлов генерируется SHA256 и вставляется в имена файлов, когда они записываются на диск. Эти имена меток используются хелперами Rails вместо имени манифеста.

Например, это:

```erb
<%= javascript_include_tag "application" %>
<%= stylesheet_link_tag "application" %>
```

сгенерирует что-то наподобие этого:

```html
<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>
<link href="/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css" rel="stylesheet" />
```

NOTE: с Asset Pipeline опции `:cache` и `:concat` больше не используются, удалите эти опции из `javascript_include_tag` и `stylesheet_link_tag`.

Режим меток контролируется с помощью инициализационной опции  [`config.assets.digest`][] (которая по умолчанию `true`).

NOTE: В нормальных обстоятельствах опция `config.assets.digest` по умолчанию не должна изменяться. Если нет дайджеста в именах файлов и установлены заголовки с вечным кэшированием, удаленные клиенты никогда не узнают, когда перезапросить файлы при изменении их содержимого.

### (precompiling-assets) Прекомпиляция ассетов

В Rails имеется встроенная команда для компиляции на диск манифестов ассетов и других файлов в файлопроводе.

Скомпилированные ассеты записываются в место расположения, указанное в [`config.assets.prefix`][]. По умолчанию это директория `/assets`.

Эту команду можно вызвать на сервере во время деплоя, чтобы создать скомпилированные версии ассетов непосредственно на сервере. Смотрите следующий раздел, чтобы узнать о том, как скомпилировать локально.

Команда следующая:

```bash
$ RAILS_ENV=production rails assets:precompile
```

Это свяжет папку, указанную в `config.assets.prefix` с `shared/assets`. Если вы уже используете эту общую папку, вам следует написать собственную команду для деплоя.

Важно то, что эта папка является общей между деплоями, так что удаленно кэшированные страницы, ссылающиеся на старые скомпилированные ассеты, все еще будут работать, пока не истечет срок кэширования.

По умолчанию компилирующиеся файлы включают `application.js`, `application.css` и все не-JS/CSS файлы (это автоматически включает все ассеты изображений) из папок `app/assets`, включая гемы:

```ruby
[ Proc.new { |filename, path| path =~ /app\/assets/ && !%w(.js .css).include?(File.extname(filename)) },
/application.(css|js)$/ ]
```

NOTE. Условие отбора (и другие части прекомпиляционного массива; смотрите выше) применяется к итоговым скомпилированным именам файлов. Это означает, что все, что компилируется в JS/CSS, исключается, так же, как и файлы с чистым JS/CSS; например, файлы `.coffee` и `.scss` *не* включаются автоматически, так как они компилируются в JS/CSS.

Если у вас имеются для включения другие манифесты или отдельные таблицы стилей или файлы JavaScript, их можно добавить самостоятельно.

При использовании **Sprockets 3**, добавьте файлы в массив `precompile` в `config/initializers/assets.rb`:

```ruby
Rails.application.config.assets.precompile += %w( admin.js admin.css )
```

При использовании **Sprockets 4**, добавьте файлы или директории в `app/assets/config/manifest.js`:

```js
//= link_tree ../images
//= link admin.js
//= link admin.css
// Или привяжите целые директории:
//= link_directory ../javascripts .js
//= link_directory ../stylesheets .css
```

NOTE. Всегда определяйте ожидаемое имя скомпилированного файла, оканчивающееся на `.js` или `.css`, даже если хотите добавить в массив прекомпиляции или файл манифеста файлы Sass или CoffeeScript.

NOTE. Подробности об отличиях между Sprockets 3 и 4 можно найти в [руководстве по обновлению Sprockets](https://github.com/rails/sprockets/blob/main/UPGRADING.md#manifestjs)

Команда также генерирует `.sprockets-manifest-randomhex.json` (где `randomhex` - это 16-байтовая случайная шестнадцатеричная строка), который содержит список всех ваших ассетов и соответствующие им метки. Это используется методами хелпера Rails, чтобы избежать направления запроса в Sprockets. Обычный файл манифеста выглядит так:

```ruby
{"files":{"application-aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b.js":{"logical_path":"application.js","mtime":"2016-12-23T20:12:03-05:00","size":412383,
"digest":"aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b","integrity":"sha256-ruS+cfEogDeueLmX3ziDMu39JGRxtTPc7aqPn+FWRCs="},
"application-86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18.css":{"logical_path":"application.css","mtime":"2016-12-23T19:12:20-05:00","size":2994,
"digest":"86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18","integrity":"sha256-hqKStQcHk8N+LA5fOfc7s4dkTq6tp/lub8BAoCixbBg="},
"favicon-8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda.ico":{"logical_path":"favicon.ico","mtime":"2016-12-23T20:11:00-05:00","size":8629,
"digest":"8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda","integrity":"sha256-jSOHuNTTLOzZP6OQDfDp/4nQGqzYT1DngMF8n2s9Dto="},
"my_image-f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493.png":{"logical_path":"my_image.png","mtime":"2016-12-23T20:10:54-05:00","size":23414,
"digest":"f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493","integrity":"sha256-9AKBVv1+ygNYTV8vwEcN8eDbxzaequY4sv8DP5iOxJM="}},
"assets":{"application.js":"application-aee4be71f1288037ae78b997df388332edfd246471b533dcedaa8f9fe156442b.js",
"application.css":"application-86a292b5070793c37e2c0e5f39f73bb387644eaeada7f96e6fc040a028b16c18.css",
"favicon.ico":"favicon-8d2387b8d4d32cecd93fa3900df0e9ff89d01aacd84f50e780c17c9f6b3d0eda.ico",
"my_image.png":"my_image-f4028156fd7eca03584d5f2fc0470df1e0dbc7369eaae638b2ff033f988ec493.png"}}
```

Место расположения манифеста по умолчанию - корень папки, определенной в `config.assets.prefix` (по умолчанию '/assets').

NOTE: Если в production отсутствуют прекомпилированные файлы, вы получите исключение `Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError`, указывающее имя отсутствующего файла(-ов).

[`config.assets.prefix`]: /configuring#config-assets-prefix

#### Вечный заголовок Expires

Прекомпилированные ассеты существуют в файловой системе и отдаются непосредственно веб-сервером. По умолчанию у них нет заголовков вечного кэширования, таким образом, чтобы получить преимущество от меток, необходимо обновить конфигурацию вашего сервера, чтобы добавить эти заголовки.

Для Apache:

```apache
# Директивы Expires* требуют, чтобы модуль Apache `mod_expires` был включен.
<Location /assets/>
  # Не рекомендуется использование ETag, когда присутствует Last-Modified
  Header unset ETag
  FileETag None
  # RFC предписывает кэшировать только на 1 год
  ExpiresActive On
  ExpiresDefault "access plus 1 year"
</Location>
```

Для NGINX:

```nginx
location ~ ^/assets/ {
  expires 1y;
  add_header Cache-Control public;

  add_header ETag "";
}
```

### Локальная прекомпиляция

Иногда вы не хотите или не можете компилировать ассеты на сервере production. Например, у вас ограниченное право записи в файловую систему production, или вы планируете часто деплоить без внесения каких-либо изменений в ваши ассеты.

В таких случаях можно прекомпилировать ассеты _локально_ — то есть добавить окончательный набор скомпилированных, готовых к production ассетов в репозиторий исходного кода перед отправлением на production. Таким образом, их не нужно прекомпилировать отдельно на сервере production при каждом деплое.

Как указано выше, это можно сделать с помощью

```bash
$ RAILS_ENV=production rails assets:precompile
```

Есть следующие оговорки:

*   Если доступны прекомпилированные ассеты, они будут отданы, даже если они больше не соответствуют оригинальным (не компилированным) ассетам, _даже на сервере development._

    Чтобы убедиться, что сервер development всегда компилирует ассеты на лету (и, таким образом, всегда отражает последнее состояние кода), среда development _должна быть настроена содержать прекомпилированные ассеты в другом месте, чем содержит production._ В противном случае, любые ассеты, прекомпилированные для использования в  production, будут ломать запросы к ним в development (_например,_ последующие сделанные изменения в ассетах не будут отражены в браузере).

    Это можно сделать, добавив следующую строчку в `config/environments/development.rb`:

    ```ruby
    config.assets.prefix = "/dev-assets"
    ```
* Задача прекомпиляции ассетов в вашей системе развертывания (_например,_ Capistrano) должна быть отключена.
* Все необходимые компрессоры или минификаторы должны быть доступны что в вашей системе development.

### Компиляция в реальном времени

В некоторых обстоятельствах, возможно, необходимо использовать компиляцию в реальном времени. В этом режиме все запросы для ассетов в файлопроводе обрабатываются непосредственно Sprockets.

Чтобы включить эту опцию, установите:

```ruby
config.assets.compile = true
```

При первом запросе ассеты компилируются и кэшируются так, как описывается в разделе про [Хранилище кэша ассетов](#assets-cache-store), и имена манифеста, использованного в хелперах, изменяется путем включения хэша SHA256.

Sprockets также устанавливает HTTP-заголовок `Cache-Control` как `max-age=31536000`. Это сигнализирует всем кэшам между вашим сервером и браузером клиента, что это содержимое (отданный файл) может быть закэшировано на 1 год. В результате уменьшается количество запросов для этого ассета на ваш сервер; есть хороший шанс, что ассет будет в локальном кэше браузера или в каком-либо промежуточном кэше.

Этот режим использует больше памяти, имеет худшее быстродействие, чем по умолчанию, и не рекомендуется.

Если приложение размещается в системе без существующего JavaScript runtimes, возможно понадобится добавить в `Gemfile` следующий фрагмент кода:

```ruby
group :production do
  gem 'mini_racer'
end
```

### (cdns) CDN

CDN расшифровывается как [Content Delivery Network](https://ru.wikipedia.org/wiki/Content_Delivery_Network), она в основном предназначена для кэширования ассетов по всему миру, поэтому когда браузер запрашивает ассет, кэшированная копия будет географически ближайшая к этому браузеру. Если отдавать ассеты непосредственно от сервера Rails в production, лучшей практикой будет использовать CDN перед приложением.

Обычным образцом использования CDN является установка вашего приложения в production как "origin" сервер. Это означает, что когда браузер запрашивает ассет из CDN, и кэш отсутствует, он возьмет файл с вашего сервера на лету и кэширует его. Например, если вы запустили приложение Rails на `example.com`, и у вас настроен CDN на `mycdnsubdomain.fictional-cdn.com`, то, когда делается запрос к `mycdnsubdomain.fictional-cdn.com/assets/smile.png`, CDN единожды запросит ваш сервер на `example.com/assets/smile.png` и кэширует запрос. Следующий запрос к CDN, пришедший по тому же самому URL, получит кэшированную копию. Когда CDN может отдать ассет напрямую, запрос никогда не затронет сервер Rails. Так как ассеты из CDN географически ближе к браузеру, запрос быстрее, и, так как серверу не нужно тратить время на раздачу ассетов, он может сфокусироваться на как можно быстром обслуживании кода приложения.

#### Настройка CDN на раздачу статических ассетов

Для настройки CDN вам нужно, чтобы ваше приложение было запущено в production в интернете на публично доступном URL, например `example.com`. Далее необходимо зарегистрироваться на сервисе CDN облачного провайдера. После этого необходимо настроить "origin" для CDN, указав ваш сайт `example.com`, по документации провайдера по настройке origin-сервера.

Подготовленный CDN даст определенный поддомен для вашего приложения, такой как `mycdnsubdomain.fictional-cdn.com` (отметьте, что fictional-cdn.com это не существующий провайдер CDN в настоящее время). Теперь, когда есть настроенный сервер CDN, необходимо сообщить браузерам использовать ваш CDN для того, чтобы брать ассеты оттуда, а не от сервера Rails. Это можно осуществить, настроив Rails, установив ваш CDN в качестве хоста ассетов, вместо использования относительного пути. Для настройки хоста ассетов в Rails, необходимо установить [`config.asset_host`][] в `config/environments/production.rb`:

```ruby
config.asset_host = 'mycdnsubdomain.fictional-cdn.com'
```

NOTE: Необходимо предоставить только "host", это поддомен и корневой домен, не нужно указывать протокол или "scheme", такие как `http://` или `https://`. Когда запрашивается страница, протокол в сгенерированной ссылке на ассет будет соответствовать тому, какой доступ к странице.

Это значение также можно настроить с помощью [переменной среды](https://ru.wikipedia.org/wiki/Переменная_среды), чтобы упростить запуск staging-копий вашего сайта:

```ruby
config.asset_host = ENV['CDN_HOST']
```

NOTE: Чтобы это работало, вам необходимо установить на сервере `CDN_HOST` значение `mycdnsubdomain.fictional-cdn.com`.

После того, как вы настроили свой сервер и ваш CDN, пути ассета из хелперов такие как:

```erb
<%= asset_path('smile.png') %>
```

Будут отрендерены полные пути к CDN, наподобие `http://mycdnsubdomain.fictional-cdn.com/assets/smile.png` (дайджест опущен для читаемости).

Если на CDN имеется копия `smile.png`, она будет отдана браузеру, и ваш сервер даже не узнает, что она была запрошена. Если на CDN нет копии, он попытается найти ее на "origin" `example.com/assets/smile.png`, а затем сохранить ее для дальнейшего использования.

Если хотите отдавать только некоторые ассеты из CDN, можно использовать опцию `:host` в хелпере ассета, переопределяющую значение, установленное в [`config.action_controller.asset_host`][].

```erb
<%= asset_path 'image.png', host: 'mycdnsubdomain.fictional-cdn.com' %>
```

[`config.action_controller.asset_host`]: /configuring#config-action-controller-asset-host
[`config.asset_host`]: /configuring#config-asset-host

#### Настройка поведения кэширования CDN

CDN работает, кэшируя содержимое. Если в CDN имеется устаревшее или плохое содержимое, то это скорее навредит, чем поможет вашему приложению. Целью этого раздела является описание основных особенностей кэширования многих CDN, поведение вашего определенного провайдера может немного отличаться.

##### Кэширование запросов CDN

Хотя CDN описывается как кэширующий файлы ассетов, на самом деле он кэширует целые запросы. Они включают тело ассета, а также его заголовки. Наиболее важным является `Cache-Control`, который сообщает CDN (и браузерам), как кэшировать содержимое. Это означает, что если кто-то запрашивает несуществующий ассет `/assets/i-dont-exist.png`, и ваше приложение Rails возвращает 404, тогда ваш CDN скорее всего закэширует страницу 404, если присутствует валидный заголовок `Cache-Control`.

##### Отладка заголовков CDN

Одним из способов проверить, что заголовки кэшируются правильно на CDN, является использование [curl](https://explainshell.com/explain?cmd=curl+-I+http%3A%2F%2Fwww.example.com). Вы можете запросить заголовки от сервера и от CDN, чтобы сверить, что они одинаковые:

```bash
$ curl -I http://www.example/assets/application-
d0e099e021c95eb0de3615fd1d8c4d83.css
HTTP/1.1 200 OK
Server: Cowboy
Date: Sun, 24 Aug 2014 20:27:50 GMT
Connection: keep-alive
Last-Modified: Thu, 08 May 2014 01:24:14 GMT
Content-Type: text/css
Cache-Control: public, max-age=2592000
Content-Length: 126560
Via: 1.1 vegur
```

Против копии на CDN.

```bash
$ curl -I http://mycdnsubdomain.fictional-cdn.com/application-
d0e099e021c95eb0de3615fd1d8c4d83.css
HTTP/1.1 200 OK Server: Cowboy Last-
Modified: Thu, 08 May 2014 01:24:14 GMT Content-Type: text/css
Cache-Control:
public, max-age=2592000
Via: 1.1 vegur
Content-Length: 126560
Accept-Ranges:
bytes
Date: Sun, 24 Aug 2014 20:28:45 GMT
Via: 1.1 varnish
Age: 885814
Connection: keep-alive
X-Served-By: cache-dfw1828-DFW
X-Cache: HIT
X-Cache-Hits:
68
X-Timer: S1408912125.211638212,VS0,VE0
```

Проверьте документацию вашего CDN, чтобы найти подробности о том, что такое `X-Cache` или любые другие добавленные ими заголовки.

##### CDN и заголовок Cache-Control

[Заголовок контроля кэша](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9) - это спецификация W3C, описывающая, как может быть закэширован запрос. Когда не используется CDN, браузер использует эту информацию для кэширования содержимого. Это очень полезно для ассетов, которые не модифицированы, так как браузеру не нужно повторно скачивать CSS или JavaScript сайта при каждом запросе. Как правило, мы хотим, чтобы наш сервер Rails сообщил нашему CDN (и браузеру), что ассет "public", что означает, что любой кэш может сохранять запрос. Также мы в основном хотим установить `max-age`, который означает, как долго кэш будет хранить объект до недействительности кэша. Значение `max-age` устанавливается в секундах с максимально возможным значением `31536000`, равным одному году. Это можно сделать в вашем приложении Rails, установив

```ruby
config.public_file_server.headers = {
  'Cache-Control' => 'public, max-age=31536000'
}
```

Теперь, когда ваше приложение отдает ассет в production, CDN сохранит ассет на один год. Так как большинство CDN также кэшируют заголовки запроса, этот `Cache-Control` будет передан всем браузерам, обращающимся к этому ассету, и браузер будет знать, что он может хранить этот ассет очень долго без необходимости повторного запроса.

##### CDN и недействительность кэша, основанного на URL

Большинство CDN кэшируют содержимое ассета, основываясь на полном URL. Это означает, что запрос к

```
http://mycdnsubdomain.fictional-cdn.com/assets/smile-123.png
```

Будет полностью по-другому закэширован, чем

```
http://mycdnsubdomain.fictional-cdn.com/assets/smile.png
```

Если хотите установить длительный `max-age` в вашем `Cache-Control` (и делаете так), то убедитесь, что, когда вы изменяете ассеты, ваш кэш прекращается. Например, при изменении рожицы смайлика в изображении с желтого на синий, вы хотите, чтобы все посетители вашего сайта получили новую синюю рожицу. При использовании CDN с настройкой файлопровода Rails `config.assets.digest`, установленной true по умолчанию, каждый ассет будет иметь другое имя, если он изменится. Таким образом, вам даже не нужно вручную прекращать любые элементы в вашем кэше. Используя иную технику для уникального имени ассета, ваши пользователи также получат самый свежий ассет.

Настройка файлопровода
----------------------

### Сжатие CSS

Одним из вариантов для сжатия CSS является YUI. [YUI CSS compressor](https://yui.github.io/yuicompressor/css.html) предоставляет минификацию.

Следующая строчка включает сжатие YUI и требует гем `yui-compressor`.

```ruby
config.assets.css_compressor = :yui
```

Имеется другой вариант для сжатия CSS, если у вас установлен гем sass-rails

```ruby
config.assets.css_compressor = :sass
```

### Сжатие JavaScript

Возможные варианты для сжатия JavaScript это `:terser`, `:closure` и `:yui`. Они требуют использование гемов `terser`, `closure-compiler` или `yui-compressor` соответственно.

Возьмем, к примеру, гем `terser`. Этот гем оборачивает [Terser](https://github.com/terser/terser) (написанный для Node.js) в Ruby. Он сжимает ваш код, убирая пробелы и комментарии, сокращая имена локальных переменных и выполняя иные микро-оптимизации, наподобие замены ваших выражений `if` и `else` на тернарные операторы там, где возможно.

Следующая строчка вызывает `terser` для сжатия JavaScript.

```ruby
config.assets.js_compressor = :terser
```

NOTE: Необходим runtime, поддерживаемый [ExecJS](https://github.com/rails/execjs#readme), чтобы использовать `terser`. Если используете macOS или Windows, у вас уже имеется JavaScript runtime, установленный в операционной системе.

### Сжатие ассетов

По умолчанию будет сгенерирована сжатая версия скомпилированных ассетов, вместе с несжатой версией ассетов. Сжатые ассеты помогают уменьшить передачу данных через канал связи. Это можно настроить, установив флажок `gzip`.

```ruby
config.assets.gzip = false # отключает генерацию сжатых ассетов
```

Обратитесь к документации своего веб-сервера за инструкцией, как раздавать сжатые ассеты.

### Использование собственного компрессора

Настройки конфигурации компрессора для CSS и JavaScript также могут принимать любой объект. Этот объект должен иметь метод `compress`, принимающий строку как единственный аргумент, и он должен возвращать строку.

```ruby
class Transformer
  def compress(string)
    do_something_returning_a_string(string)
  end
end
```

Чтобы включить это, передайте новый объект в конфигурационную опцию в `application.rb`:

```ruby
config.assets.css_compressor = Transformer.new
```

### Изменение пути _assets_

Публичный путь, используемый Sprockets по умолчанию, это `/assets`.

Он может быть заменен на что-то другое:

```ruby
config.assets.prefix = "/some_other_path"
```

Это удобная опция, если вы обновляете старый проект, не использующий файлопровод и уже использующий этот путь, или вы хотите использовать этот путь для нового ресурса.

### Заголовки X-Sendfile

Заголовок X-Sendfile — это указание веб-серверу игнорировать отклик от приложения, и вместо этого отдать определенный файл с диска. Эта опция отключена по умолчанию, но может быть включена, если ее поддерживает сервер. Когда опция включена, обязанность по отдаче файла передается веб-серверу, который справляется с ней быстрее. Обратитесь к [send_file](https://api.rubyonrails.org/classes/ActionController/DataStreaming.html#method-i-send_file), чтобы узнать, как использовать эту особенность.

Apache и NGINX поддерживают эту опцию. Она включается в `config/environments/production.rb`.

```ruby
# config.action_dispatch.x_sendfile_header = "X-Sendfile" # для Apache
# config.action_dispatch.x_sendfile_header = 'X-Accel-Redirect' # для NGINX
```

WARNING: Если вы производите апгрейд существующего приложения и намереваетесь использовать эту опцию, убедитесь, что скопировали ее только в `production.rb` и в любую другую среду, которую вы определили, как имеющую поведение production (не в `application.rb`).

TIP: За дальнейшими подробностями обращайтесь к документации своих веб-серверов:

- [Apache](https://tn123.org/mod_xsendfile/)
- [NGINX](https://wiki.nginx.org/XSendfile)

(assets-cache-store) Хранилище кэша ассетов
-------------------------------------------

По умолчанию Sprockets кэширует ассеты в `tmp/cache/assets` в development и production. Это может быть изменено следующим образом:

```ruby
config.assets.configure do |env|
  env.cache = ActiveSupport::Cache.lookup_store(:memory_store,
                                                { size: 32.megabytes })
end
```

Чтобы отключить хранилище кэша ассетов:

```ruby
config.assets.configure do |env|
  env.cache = ActiveSupport::Cache.lookup_store(:null_store)
end
```

Добавление ассетов в ваши гемы
------------------------------

Ассеты также могут идти от внешних источников в виде гемов.

Хорошим примером этого является гем `jquery-rails`. Этот гем содержит класс engine, унаследованный от `Rails::Engine`. Сделав так, Rails становится проинформированным, что директории для этого гема могут содержать ассеты, и директории `app/assets`, `lib/assets` и `vendor/assets` этого engine добавляются в путь поиска Sprockets.

Создание препроцессора в вашей библиотеке или геме
--------------------------------------------------

Sprockets использует Процессоры, Трансформеры, Компрессоры и Экспортеры для расширения функциональности Sprockets. Обратитесь к [Расширение Sprockets](https://github.com/rails/sprockets/blob/master/guides/extending_sprockets.md), чтобы узнать больше об этом. Здесь мы зарегистрировали препроцессор, чтобы добавить комментарий в конец text/css (`.css`) файлов.

```ruby
module AddComment
  def self.call(input)
    { data: input[:data] + "/* Hello From my sprockets extension */" }
  end
end
```

Теперь, когда у вас есть модуль, который модифицирует входные данные, самое время зарегистрировать его как препроцессор для вашего типа MIME.

```ruby
Sprockets.register_preprocessor 'text/css', AddComment
```
